# Java面试
> B站地址：[https://www.bilibili.com/video/BV1Tq4y1L7NY?p=1](https://www.bilibili.com/video/BV1Tq4y1L7NY?p=1)

## ArrayList和LinkedList区别
* ArrayList：底层是动态数组，连续的内存空间存储，相对查询性能高、线程不安全、轻量级、初始化10，每次扩容为x1.5
* LinkedList：底层是双向循环链表，相对增删效率高，线程不安全，轻量级;同时实现了Deque接口 可以当作双端队列使用


## HashMap的put方法(1.7/1.8)
* 流程：key通过hash计算得到数组下标，下标位置元素为空则将key/value封装成Entry放入该位置，不为空则区分1.7和1.8
* 1.7(数组 + 链表)：先判断是否需要扩容 扩容之后生成Entry对象，使用头插法放入链表中
* 1.8(数组 + 链表 + 红黑树)：先判断是红黑树还是链表，红黑树的话则封装好红黑树后添加到红黑树中，链表的话则使用尾插法插入到链表最后的位置 插入完成后会判断是否要转变为红黑树，插入完成之后再判断是否需要扩容
* 如果key已经存在则会覆盖value值；jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在；反之则会回退为链表；

## ThreadLocal
* ThreadLocal：每一个Thread对象都含有一个ThreadLocalMap类型的成员变量，它存储本线程中所有TheadLocal对象及其对应的值，Map的key为ThreadLocal对象，Map的value为需要缓存的值
* 使用场景：在对象进行跨层传递时，使用ThreadLocal可以避免多次传递；线程间数据隔离；进行事务操作 用于存储线程事务信息；数据库连接 Session会话管理
* 每次使用完ThreadLocal都调用它的remove()方法清除数据
* 将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉

## JVM中那些是共享区，那些可以作为GC ROOT
* 共享区：方法区(类)、堆(对象)
* 线程独有：虚拟机栈、本地方法栈、程序计数器
* GC ROOT：可达性分析法中的根部，正在运行的线程、方法区中的静态变量、本地方法栈中的变量、栈中的本地变量

## JVM问题排查
* 正在运行的系统：jmap查看JVM各个区域的使用情况；jstack查看线程运行的情况；jstat查看垃圾回收情况(full gc)；
* 已经出现OOM的系统：通过jdk工具生成当时的dump文件；阿里的Arthas工具等

## 线程死锁的查看
* 可以使用jstack，阿里的Arthas工具等

## 线程间是如何通讯的
* 基于共享内存或基于网络
* 如果是共享内存的话则是wait(),notify()

## spring的大致流程
* Spring是一个轻量级的控制反转（IoC)和面向切面（AOP）的容器框架，这里主要讲一下spring的启动流程(创建spring容器)
* 1.进行扫描，得到所有的BeanDefinition对象 储存到map中
* 2.筛选出非懒加载的单例BeanDefinition进行创建Bean，对于多例和懒加载的Bean 会在每次获取Bean的时候利用BeanDefinition去创建
* 3.利用BeanDefinition创建Bean(创建生命周期)，期间包含合并BeanDefinition、推断构造方法、实例化、属性填充、初始化前、初始化、初始化后(AOP)等
* 4.单例Bean创建完成之后，spring会发布一个容器启动事件
* 5.同时spring启动时会提供一些模板方法 让子类来实现
* 6.启动过程中处理@Import等注解
* 7.Spring启动完成

## spring事务机制
* spring的事务是基于数据库事务和AOP机制的
* 对于使用了@Transactional注解的Bean，spring会创建一个代理对象Bean
* 当调用代理对象方法时 会判断该方法是否加了@Transactional注解 如果加了则会使用事务管理器创建一个数据库连接
* 并且会修改数据库连接的autocommit属性为false，关闭自动提交
* 然后执行当前方法 执行sql
* 如果出现了异常 并且这个异常是需要回滚事务的话就会回滚事务，否则仍然提交事务
* 其他：spring的事务隔离级别就是数据库的隔离级别，spring事务的传播机制是自己实现的 一个事务就是一个数据库连接

## spring事务什么时候会失效
* spring事务的原理就是AOP进行了切面增强，AOP不起作用时就会失效 如下：
* 发生自调用：类中使用this调用本来方法
* 方法不是public（@Transactional只支持public）,如果非要非public的话可以开启Aspectj代理模式
* 数据库不支持事务
* 类没有交给spring管理
* 异常没有抛出

## spring事务什么时候会失效
* spring事务的原理就是AOP进行了切面增强，AOP不起作用时就会失效 如下：
* 发生自调用：类中使用this调用本来方法
* 方法不是public（@Transactional只支持public）,如果非要非public的话可以开启Aspectj代理模式
* 数据库不支持事务
* 类没有交给spring管理
* 异常没有抛出

## Dubbo是如何系统交互的
* Dubb底层是通过RPC来完成服务和服务之间的调用的  默认支持dubbo协议、http协议、rest协议等
* 服务消费者在调用某个服务是 会将当前所调用的服务接口信息、方法信息、参数信息组装成Invocation对象
* 不同的协议通过不同的数据组织⽅式和传输⽅式将这个对象传送 给服务提供者
* 提供者接收到这个对象后，找到对应的服务实现，利⽤反射执⾏对应的⽅法，得到⽅法结 果后再通过⽹络响应给服务消费者
* 还做很多其他的设计：服务容错、负载均衡、Filter机制、动态路由机 制等等

## Dubbo的负载均衡机制
* 平衡加权轮询算法 
* 加权随机算法 
* ⼀致性哈希算法 
* 最⼩活跃数算法

## HashMap1.7/1.8的变化
* 1.7中底层是数组+链表，1.8中底层是数组+链表+红⿊树，加红⿊树的⽬的是提⾼HashMap插⼊和查询 整体效率
* 1.7中链表插⼊使⽤的是头插法，1.8中链表插⼊使⽤的是尾插法，因为1.8中插⼊key和value时需要判断 链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使⽤尾插法
* 1.7中哈希算法⽐较复杂，存在各种右移与异或运算，1.8中进⾏了简化,复杂的哈希算法的⽬的就 是提⾼散列性；⽽1.8中新增了红⿊树，所以可以适当的简化哈希算法， 节省CPU资源

## 虚拟机1.7/1.8的变化
* 1.7存在永久代，1.8中没有了永久代(替换为元空间)
* 元空间所占内存不是在虚拟机内部 而是在本地内存中

## AOP如何实现的
* AOP：利用动态代理技术来实现 如：JDK动态代理/Cglib动态代理，利用动态代理技术可以针对某个类生成代理对象
* SpringBoot中的事务、权限控制、日志等等都是要用到AOP技术利⽤AOP可以做到业务⽆侵⼊

## Spring的后置处理器
* BeanFactory后置处理器和Bean后置处理器，Spring在创建一个Bean的过程中 首先会实例化一个对象，然后利用Bean后置处理器来堆该实例进行加工 如：依赖注入、AOP等等
* AOP，也是利⽤⼀个Bean后置处理器来实现的，基于原实例对象，判断是否需要进⾏AOP，如果需 要，那么就基于原实例对象进⾏动态代理，⽣成⼀个代理对象。

## SpringBoot常用注解及其实现
* @SpringBootApplication注解：标识了一个SpringBoot工程 实际上是三个注解的集合
    1. @SpringBootConfiguration：实际上就是一个@Configuration 标识启动类也是一个配置类
    2. @EnableAutoConfiguration：向Spring容器中导入一个Selector，用来加载ClassPath下SpringFactories中所定义的自动配置类，将这些自动加载为配置Bean
    3. @ComponentScan：标识扫描路径  默认是没有配置实际的扫描路径，所以SpringBoot的扫描路径就是启动类所在的目录
* @Bean：用来定义Bean，类似于XML中的<bean>标签 启动时对加了该注解的方法进行解析 并通过执行方法得到bean对象
* @Controller、@Service、@ResponseBody、@Autowired等等

## 分布式锁解决方案-需要这个锁独立于每一个服务之外
* 数据库：利用主键冲突控制一次只有一个线程能获取锁（多个线程去插入同一个id的数据 能插入表示拿到锁了），非阻塞、不可重入、单点、失效时间
* Zookeeper分布式锁：zk通过临时节点，解决了死锁的问题，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临 时节点就会自动删除掉，其他客户端自动获取锁。临时顺序节点解决惊群效应
* Redis分布式锁：setNX 所有服务节点设置相同的key，返回为0、则锁获取失败，单线程处理网络请求，不需要考虑并发安全性；缺点：早期版本没有超时参数，需要单独设置，存在死锁问题；存在任务超时，锁自动释放，导致并发问题，加锁与释放锁不是同一线程问题

## Redis数据结构
* 字符串：可以⽤来做最简单的数据缓存，可以缓存某个简单的字符串，也可以缓存某个json格式的字符 串，Redis分布式锁的实现就利⽤了这种数据结构，还包括可以实现计数器、Session共享、分布式ID
* 哈希表可以⽤来存储⼀些key-value对，更适合⽤来存储对象
* 列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使⽤，可以⽤来缓存类似微信 公众号、微博等消息流数据
* 集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进⾏交集、并集、差集操作，从⽽ 可以实现类似，我和某⼈共同关注的⼈、朋友圈点赞等功能
* 有序集合：集合是⽆序的，有序集合可以设置顺序，可以⽤来实现排⾏榜功能

## Redis集群策略
* 主从模式：主库可以读写 且回和从库进行数据同步，客户端直接连接主库或从库；缺点是 1.如果连接的主库或者从库宕机那么服务就要去修改连接信息，2.比较难进行扩容 整个集群储存收到主库机器的内存限制
* 哨兵模式：在主从模式的基础上新增哨兵节点，主库宕机之后 哨兵节点会从从库中选择一个库作为主库，同时哨兵也可以做集群 确保哨兵一直可用；但缺点仍然是 无法扩容
* Cluster模式(推荐)：支持多主多从，会根据key进行槽位的分配 可以使key分散到不同的节点上去 然后主节点再将数据同步到子节点上，这样容量就得到了大的提升 同时主节点宕机后会从从节点选择一个作为新的主节点

## 索引失效
* 没有符合最左前缀原则
* 字段进行了隐式数据类型转换
* 走索引没有全表扫描效率高

## Innodb如何实现事务的
* Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务 步骤如下：
* Innodb在收到一个update语句后 会先根据条件找到数据所在的页 并将该页缓存到Buffer Pool中
* 执行update语句 修改Buffer Pool中的数据，也就是内存中的数据
* 针对update语句生成一个RedoLog对象 并存入LogBuffer中
* 针对update语句生成undolog日志 用于事务回滚
* 如果事务提交 那么就吧RedoLog对象进行持久化，后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中
* 如果事务有回滚 则利用undolog日志进行回滚

## 项目相关
* 项目是做什么的
* 用了什么技术，解决了什么项目难点，优化了扫描项目功能
* 在项目中担任的职位
* 收获了什么

## 常见的设计模式
* 代理模式：Mybatis中用到的JDK动态代理来生成一些Mapper对象，在执行代理对象的方法时会去执行sql；Spring中的AOP、@Configuration注解也都是用的代理模式
* 责任链模式：Tomcat中的Pipeline实现，及Dubbo中的Filter机制都是使用了责任链模式
* 工厂模式：Spring中的BeanFactory就是工厂模式的一种实现
* 适配器模式：Spring中的Bean销毁的生命周期中就用到了适配器模式 用来适配各种Bean的销毁逻辑方式
* 模板方法模式：Spring中的refresh方法中就提供了给子类继承重写的方法，就是用到了模板方法模式

## Java死锁如何避免
* 含义：当一个线程永远地持有一个锁，并且其他线程都尝试获得这个锁时，那么它们将永远被阻塞
* 原因：一个资源每次只能被一个线程使用；线程在阻塞等待某个资源时不释放已占用的资源；一个线程已经获得的资源 在未使用之前不能被强行剥夺；若干线程形成头尾相接的循环等待资源关系
* 解决方案：注意加锁顺序 保证每个线程按照同样的顺序进行加锁；注意加锁的时限 可以设置一个超时时间；注意死锁的检查；

## 深拷贝和浅拷贝
* 浅拷贝：只会拷贝基本数据类型的值，以及实例对象的引用地址 并不会复制一份引用地址所指向的对象
* 深拷贝：既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行拷贝

## 线程池中如果提交任务时 线程池队列已满这时会发生什么
* 无界队列的话(没有指定队列大小 直到溢出)：继续提交任务也没关系
* 有界队列的话(指定队列大小)：如果线程数量没有超出最大值 没有超出则会创建线程，超过最大值的话就执行拒绝策略

## ConcurrentHashMap原理，jdk7和jdk8版本的区别
* jdk7：基于ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEntry数组，每个HashEntry又是一个链表结构
* jdk8：基于synchronized+CAS+Node+红黑树，Node的val和next都用volatile修饰，保证可见性查找，替换，赋值操作都使用CAS

## ConcurrentHashMap的扩容机制
* jdk7：基于Segment分段实现，每个Segment就是一个小型的HashMap 扩容时先生成新的数组然后转移到新数组中，扩容判断也是Segment内部单独判断的
* jdk8：基于CAS+Node+红黑树，扩容是新创建一个数组 转移时先将原数组分组，将每组元素分给不同的线程进行元素转移 每个线程负责一组或者多组的元素转移

## Spring中的Bean是线程安全的吗
* Spring本身没有针对Bean做线程安全处理，如果Bean是无状态的那么就是线程安全的，如果Bean是有状态的那么则是线程不安全的；同时和Bean的作用域无关

## SpringCloudAlibaba各个组件功能
* Nacos：服务注册中心和服务配置中心
* Sentinel：服务流控、服务降级
* Seata：分布式系统下事务问题

## Java类加载器和双亲委派模型
* BootstrapClassLoader、ExtClassLoader、AppClassLoader
* 双亲委派：AppClassLoader加载时先不自己家族 而是让自己的上级加载，当上级没加载到的话再由自己加载
* 向上委派（上级加载器排查是否有加载过 有就直接返回）、向下查找（根据路径排查 有就直接返回）
* 主要是为了安全性，避免用户自己编写的类动态替换 Java的一些核心类，比如 String。
* 同时也避免了类的重复加载，因为 JVM中区分不同类，不仅仅是根据类名，相同的 class文件被不同的 ClassLoader加载就是不同的两个类

## 并发编程三要素
* 原子性：不可分割的操纵
* 有序性：程序执行的顺序和代码顺序保持一致
* 可用性：一个线程对共享变量的修改 另一个线程能立马看到

## Spring中用到了那些设计模式
* 工厂模式：BeanFactory
* 适配器模式：AdvisorAdapter接口 对Advisor进行了适配
* 装饰器模式：BeanWrapper 
* 代理模式：AOP
* 观察者模式：事件监听机制
* 模板模式：JdbcTemplater
* 委派模式：BeanDefinitionParseDelegate
* 责任链模式：BeanPostProcessor

## CAP理论
* C一致性：指的是分布式系统中的数据一致性
* A可用性：表示分布式系统中是否正常可用
* P分区容错：表示分布式系统中出现网络问题时的容错
* P是绝对要保证的，但同时只能满足AP 或 CP
* BASE理论：指分布式系统不需要保证数据的强一致性，只要做到最终一致性 也不需要保证一直可用，只需要保证基本可用

## 快排算法
* 底层使用分治法：取出数列中的第一个数作为基准数；将数列中的比基准数大的放在右边 小的放在左边；然后对左右两部分重复第二个操作直到各区间只有一个数

## TCP的三次握手和四次挥手
* 在建立TCP连接时 需要通过三次握手来建立，断开TCP连接时需要通过四次挥手来断开
* 三次握手：客户端向服务端发送一个SYN；服务端收到SYN之后 返回一个SYN_ACK；客户段收到SYN_ACK之后 再给服务端发送一个ACK
* 四次挥手：客户端向