# Java面试
> B站地址：[https://www.bilibili.com/video/BV1Tq4y1L7NY?p=1](https://www.bilibili.com/video/BV1Tq4y1L7NY?p=1)

## ArrayList和LinkedList区别
* ArrayList：底层是动态数组，连续的内存空间存储，相对查询性能高、线程不安全、轻量级、初始化10，每次扩容为x1.5
* LinkedList：底层是双向循环链表，相对增删效率高，线程不安全，轻量级;同时实现了Deque接口 可以当作双端队列使用


## HashMap的put方法(1.7/1.8)
* 流程：key通过hash计算得到数组下标，下标位置元素为空则将key/value封装成Entry放入该位置，不为空则区分1.7和1.8
* 1.7(数组 + 链表)：先判断是否需要扩容 扩容之后生成Entry对象，使用头插法放入链表中
* 1.8(数组 + 链表 + 红黑树)：先判断是红黑树还是链表，红黑树的话则封装好红黑树后添加到红黑树中，链表的话则使用尾插法插入到链表最后的位置 插入完成后会判断是否要转变为红黑树，插入完成之后再判断是否需要扩容
* 如果key已经存在则会覆盖value值；jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在；反之则会回退为链表；

## ThreadLocal
* ThreadLocal：每一个Thread对象都含有一个ThreadLocalMap类型的成员变量，它存储本线程中所有TheadLocal对象及其对应的值，Map的key为ThreadLocal对象，Map的value为需要缓存的值
* 使用场景：在对象进行跨层传递时，使用ThreadLocal可以避免多次传递；线程间数据隔离；进行事务操作 用于存储线程事务信息；数据库连接 Session会话管理
* 每次使用完ThreadLocal都调用它的remove()方法清除数据
* 将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉

## JVM中那些是共享区，那些可以作为GC ROOT
* 共享区：方法区(类)、堆(对象)
* 线程独有：虚拟机栈、本地方法栈、程序计数器
* GC ROOT：可达性分析法中的根部，正在运行的线程、方法区中的静态变量、本地方法栈中的变量、栈中的本地变量

## JVM问题排查
* 正在运行的系统：jmap查看JVM各个区域的使用情况；jstack查看线程运行的情况；jstat查看垃圾回收情况(full gc)；
* 已经出现OOM的系统：通过jdk工具生成当时的dump文件；阿里的Arthas工具等

## 线程死锁的查看
* 可以使用jstack，阿里的Arthas工具等

## 线程间是如何通讯的
* 基于共享内存或基于网络
* 如果是共享内存的话则是wait(),notify()

## spring的大致流程
* Spring是一个轻量级的控制反转（IoC)和面向切面（AOP）的容器框架，这里主要讲一下spring的启动流程(创建spring容器)
* 1.进行扫描，得到所有的BeanDefinition对象 储存到map中
* 2.筛选出非懒加载的单例BeanDefinition进行创建Bean，对于多例和懒加载的Bean 会在每次获取Bean的时候利用BeanDefinition去创建
* 3.利用BeanDefinition创建Bean(创建生命周期)，期间包含合并BeanDefinition、推断构造方法、实例化、属性填充、初始化前、初始化、初始化后(AOP)等
* 4.单例Bean创建完成之后，spring会发布一个容器启动事件
* 5.同时spring启动时会提供一些模板方法 让子类来实现
* 6.启动过程中处理@Import等注解
* 7.Spring启动完成

## spring事务机制
* spring的事务是基于数据库事务和AOP机制的
* 对于使用了@Transactional注解的Bean，spring会创建一个代理对象Bean
* 当调用代理对象方法时 会判断该方法是否加了@Transactional注解 如果加了则会使用事务管理器创建一个数据库连接
* 并且会修改数据库连接的autocommit属性为false，关闭自动提交
* 然后执行当前方法 执行sql
* 如果出现了异常 并且这个异常是需要回滚事务的话就会回滚事务，否则仍然提交事务
* 其他：spring的事务隔离级别就是数据库的隔离级别，spring事务的传播机制是自己实现的 一个事务就是一个数据库连接

## spring事务什么时候会失效
* spring事务的原理就是AOP进行了切面增强，AOP不起作用时就会失效 如下：
* 发生自调用：类中使用this调用本来方法
* 方法不是public（@Transactional只支持public）,如果非要非public的话可以开启Aspectj代理模式
* 数据库不支持事务
* 类没有交给spring管理
* 异常没有抛出

## spring事务什么时候会失效
* spring事务的原理就是AOP进行了切面增强，AOP不起作用时就会失效 如下：
* 发生自调用：类中使用this调用本来方法
* 方法不是public（@Transactional只支持public）,如果非要非public的话可以开启Aspectj代理模式
* 数据库不支持事务
* 类没有交给spring管理
* 异常没有抛出

## Dubbo是如何系统交互的
* Dubb底层是通过RPC来完成服务和服务之间的调用的  默认支持dubbo协议、http协议、rest协议等
* 服务消费者在调用某个服务是 会将当前所调用的服务接口信息、方法信息、参数信息组装成Invocation对象
* 不同的协议通过不同的数据组织⽅式和传输⽅式将这个对象传送 给服务提供者
* 提供者接收到这个对象后，找到对应的服务实现，利⽤反射执⾏对应的⽅法，得到⽅法结 果后再通过⽹络响应给服务消费者
* 还做很多其他的设计：服务容错、负载均衡、Filter机制、动态路由机 制等等

## Dubbo的负载均衡机制
* 平衡加权轮询算法 
* 加权随机算法 
* ⼀致性哈希算法 
* 最⼩活跃数算法

## HashMap1.7/1.8的变化
* 1.7中底层是数组+链表，1.8中底层是数组+链表+红⿊树，加红⿊树的⽬的是提⾼HashMap插⼊和查询 整体效率
* 1.7中链表插⼊使⽤的是头插法，1.8中链表插⼊使⽤的是尾插法，因为1.8中插⼊key和value时需要判断 链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使⽤尾插法
* 1.7中哈希算法⽐较复杂，存在各种右移与异或运算，1.8中进⾏了简化,复杂的哈希算法的⽬的就 是提⾼散列性；⽽1.8中新增了红⿊树，所以可以适当的简化哈希算法， 节省CPU资源

## 虚拟机1.7/1.8的变化
* 1.7存在永久代，1.8中没有了永久代(替换为元空间)
* 元空间所占内存不是在虚拟机内部 而是在本地内存中

## AOP如何实现的
* AOP：利用动态代理技术来实现 如：JDK动态代理/Cglib动态代理，利用动态代理技术可以针对某个类生成代理对象
* SpringBoot中的事务、权限控制、日志等等都是要用到AOP技术利⽤AOP可以做到业务⽆侵⼊

## Spring的后置处理器
* BeanFactory后置处理器和Bean后置处理器，Spring在创建一个Bean的过程中 首先会实例化一个对象，然后利用Bean后置处理器来堆该实例进行加工 如：依赖注入、AOP等等
* AOP，也是利⽤⼀个Bean后置处理器来实现的，基于原实例对象，判断是否需要进⾏AOP，如果需 要，那么就基于原实例对象进⾏动态代理，⽣成⼀个代理对象。

## SpringBoot常用注解及其实现
* @SpringBootApplication注解：标识了一个SpringBoot工程 实际上是三个注解的集合
    1. @SpringBootConfiguration：实际上就是一个@Configuration 标识启动类也是一个配置类
    2. @EnableAutoConfiguration：向Spring容器中导入一个Selector，用来加载ClassPath下SpringFactories中所定义的自动配置类，将这些自动加载为配置Bean
    3. @ComponentScan：标识扫描路径  默认是没有配置实际的扫描路径，所以SpringBoot的扫描路径就是启动类所在的目录
* @Bean：用来定义Bean，类似于XML中的<bean>标签 启动时对加了该注解的方法进行解析 并通过执行方法得到bean对象
* @Controller、@Service、@ResponseBody、@Autowired等等

## 分布式锁解决方案-需要这个锁独立于每一个服务之外
* 数据库：利用主键冲突控制一次只有一个线程能获取锁（多个线程去插入同一个id的数据 能插入表示拿到锁了），非阻塞、不可重入、单点、失效时间
* Zookeeper分布式锁：zk通过临时节点，解决了死锁的问题，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临 时节点就会自动删除掉，其他客户端自动获取锁。临时顺序节点解决惊群效应
* Redis分布式锁：setNX 所有服务节点设置相同的key，返回为0、则锁获取失败，单线程处理网络请求，不需要考虑并发安全性；缺点：早期版本没有超时参数，需要单独设置，存在死锁问题；存在任务超时，锁自动释放，导致并发问题，加锁与释放锁不是同一线程问题

## Redis数据结构
* 字符串：可以⽤来做最简单的数据缓存，可以缓存某个简单的字符串，也可以缓存某个json格式的字符 串，Redis分布式锁的实现就利⽤了这种数据结构，还包括可以实现计数器、Session共享、分布式ID
* 哈希表可以⽤来存储⼀些key-value对，更适合⽤来存储对象
* 列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使⽤，可以⽤来缓存类似微信 公众号、微博等消息流数据
* 集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进⾏交集、并集、差集操作，从⽽ 可以实现类似，我和某⼈共同关注的⼈、朋友圈点赞等功能
* 有序集合：集合是⽆序的，有序集合可以设置顺序，可以⽤来实现排⾏榜功能

## Redis集群策略
* 主从模式：主库可以读写 且回和从库进行数据同步，客户端直接连接主库或从库；缺点是 1.如果连接的主库或者从库宕机那么服务就要去修改连接信息，2.比较难进行扩容 整个集群储存收到主库机器的内存限制
* 哨兵模式：在主从模式的基础上新增哨兵节点，主库宕机之后 哨兵节点会从从库中选择一个库作为主库，同时哨兵也可以做集群 确保哨兵一直可用；但缺点仍然是 无法扩容
* Cluster模式(推荐)：支持多主多从，会根据key进行槽位的分配 可以使key分散到不同的节点上去 然后主节点再将数据同步到子节点上，这样容量就得到了大的提升 同时主节点宕机后会从从节点选择一个作为新的主节点

## 索引失效
* 没有符合最左前缀原则
* 字段进行了隐式数据类型转换
* 走索引没有全表扫描效率高

## Innodb如何实现事务的
* Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务 步骤如下：
* Innodb在收到一个update语句后 会先根据条件找到数据所在的页 并将该页缓存到Buffer Pool中
* 执行update语句 修改Buffer Pool中的数据，也就是内存中的数据
* 针对update语句生成一个RedoLog对象 并存入LogBuffer中
* 针对update语句生成undolog日志 用于事务回滚
* 如果事务提交 那么就吧RedoLog对象进行持久化，后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中
* 如果事务有回滚 则利用undolog日志进行回滚

## 项目相关
* 项目是做什么的
* 用了什么技术，解决了什么项目难点，优化了扫描项目功能
* 在项目中担任的职位
* 收获了什么